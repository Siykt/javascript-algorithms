# 排序算法

了解排序法是学习算法的必经之路. 所谓排序法, 就是将一堆没有排序过的数字由小到大 (或大到小) 排列好的算法

用一张图概括：

![](http://filebed.xxlsjfx.com/osx/1666274790570.png1666274790533.png)

## 算法实现

- [x] 插入排序 [insertionSort.ts](./insertionSort.ts)
- [x] 冒泡排序 [bubbleSort.ts](./bubbleSort.ts)
- [x] 选择排序 [selectionSort.ts](./selectionSort.ts)
- [x] 希尔排序 [shellSort.ts](./shellSort.ts)
- [ ] 归并排序
- [ ] 快速排序
- [ ] 堆排序
- [ ] 计数排序
- [ ] 桶排序
- [ ] 基数排序

## 插入排序 (Insertion Sort)

插入排序是一种最简单直观的排序算法, 它的工作原理是通过构建有序序列, 对于未排序数据, 在已排序序列中从后向前扫描, 找到相应位置并插入.

### 复杂度

时间复杂度：O(N^2)

空间复杂度：O(1)

### 算法步骤

基本来说, 插入排序只需要重复执行两个步骤, 分别是:

    1. 从 [未排序好的数字] 取出第一个与 [已排序好的数字] 比较
    2. 如果 [已排序好的数字] 大于 [未排序好的数字], 则将 [已排序好的数字] 后移一位, 否则直接插入

### 动图演示

![](http://filebed.xxlsjfx.com/osx/1666274640047.gifbubbleSort.gif)

可以看出来插入排序还是比较直观好理解的, 而且是稳定的.

### 参考

[1.3 插入排序- 菜鸟教程](https://www.runoob.com/w3cnote/insertion-sort.html)

## 冒泡排序

冒泡排序 (Bubble Sort) 也是一种简单直观的排序算法. 它重复地走访过要排序的数列, 一次比较两个元素, 如果他们的顺序错误就把他们交换过来. 走访数列的工作是重复地进行直到没有再需要交换, 也就是说该数列已经排序完成. 这个算法的名字由来是因为越小的元素会经由交换慢慢 **"浮"** 到数列的顶端.

### 复杂度

时间复杂度: O(N^2)

空间复杂度: O(1)

### 算法步骤

冒泡排序的算法步骤非常简单, 就只有一步: **比较相邻的元素, 如果第一个比第二个大, 就交换他们两个**

> 暴力美学!!!

### 动图演示

![](http://filebed.xxlsjfx.com/osx/1666274640047.gifbubbleSort.gif)

## 选择排序

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

### 复杂度

时间复杂度: O(N^2)

空间复杂度: O(1)

### 算法步骤

首先在未排序序列中找到最小的元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小的元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

### 动图演示

![](http://filebed.xxlsjfx.com/win/2022-10-31-1667193264604.gif)

## 希尔排序

希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。

希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。

它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。

### 复杂度

时间复杂度: O(N^(1.3-2))

空间复杂度: O(1)

### 算法步骤

选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；

按增量序列个数 k，对序列进行 k 趟排序；

每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。
仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 动图演示

![](http://filebed.xxlsjfx.com/win/2022-12-27-1672153700366.gif)
